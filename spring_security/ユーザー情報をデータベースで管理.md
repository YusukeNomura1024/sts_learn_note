## UserDetailsとUserDetailsServiceを理解しよう
* UserDetails
    * ユーザー名・パスワード・権限などの情報を持つ
    * ref.API Doc
* UserDetailsService
    * UserDetailsを取得するメソッドを持つ（localUserByUsername)
    * ref.API Doc

* 実装
    * どちらもインターフェースなので、実装用のクラスを作成します
    * 例ではCustomUserDetailsとCustomUserDetailsServiceを作ります
    * パッケージ名はauthとかにします
    * authの中にcustomUserDetailsServiceを作成します。
    * implements UserDetailsServiceとします。（この時点ではまだ、UserDetailsServiceのメソッドを実装していないのでエラーが出ます。
        * intelijの使い方でctrl+Iで実装できるメソッド一覧が選べます。
    * selected method 'loadUserByUsername'
    * 'loadUserByUsername' は見つからなかった場合は、UsernameNotFoundExceptionが発生するようになっている。
    * 今回は仮実装なので、すべてUsernameNotFoundExceptionが発生するようにしておきます。
    * UserDetailsServiceを spring securityに登録します。（これは通常のやり方です）登録することで、springsecurityでメソッドをオーバーライドするという形をとります。
    ```java
    package com.example.its.domain.auth;

    import org.springframework.security.core.userdetails.UserDetails;
    import org.springframework.security.core.userdetails.UserDetailsService;
    import org.springframework.security.core.userdetails.UsernameNotFoundException;
    import org.springframework.stereotype.Service;

    @Service
    public class CustomUserDetailsService implements UserDetailsService {

        @Override
        public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
            throw new UsernameNotFoundException(
                    "Given username is not found. (username = '" + username + "')"
            );
        }
    }
    ```
    * WebSecurityConfigurerAdapterを継承している、SecurityConfigクラスでメソッドをオーバーライドします。
        * ctrl+o でオーバーライドできるメソッド一覧が表示されます。
        * 引数にAuthenticationManagerBuilderをとるconfigureを選択します。
        * 中身をauth.userDetailsService()として上書きすることで、CustomUserDetailsServiceを登録できます。
        * SecurityConfigクラスに「@RequiredArgsConstructor」をつけて、フィールドにUserdetailsServiceを登録します。
            ```java
            private final UserDetailsService userDetailsService;
            ```
        * @RequiredArgsConstructorをつけることで、上記のように初期化されていないフィールドを初期化したことにして、this.userDetailsService = userDetailsServiceといったコンストラクターの記述も省略でき、コンストラクターが自動でuserDetailsServiceを引数に取るようになります。(UserDetailsServiceは@Serviceがついているので、DIで管理されています。)
            ```java
            SecurityConfig()
            // 上記のコンストラクターが
            securityConfig(UserDetailsService)
            // となる
            ```
        * 先ほどオバーライドの記述の途中だったconfigureメソッドのauth.userDetailsService()の（）にuserDetailsServiceと記述することで、authのuserDetailsServiceにuserDetailsServiceを登録することができました。
            ```java
            @Override
            protected void configure(AuthenticationManagerBuilder auth) throws Exception {
                auth.userDetailsService(userDetailsService);
            }
            ```
    * デバッグをしてみると、、、authのuserDetailsServiceがUserDetailsServiceクラスが設定されており、それを実装しているCustomUserDetailsServiceクラスのloadUserByUsernameメソッドでブレークポイントを設定することで、ログインを行ったときに、しっかりと停止しており、引数のusernameにも入力したユーザー名が反映されていることが確認できるはずです。

    * UserDetailsをCustomUserDetailsクラスで実装します。
        * authパッケージにUserDetailsクラスを作成し、org.springframework.security.core.userdetails.のUserクラスをextends（継承）します。
        * このUserクラスはspring securityが提供しているくらすで、これを継承することで、UserDetailsに必要な記述を最小限にすることができます。
        * CustomUserDetails(String username, String password, Collection<? extends GrantedAuthority> authorities)というコンストラクターを作成します。
            ```java 
            public class CustomUserDetails extends User {

                public CustomUserDetails(String username, String password, Collection<? extends GrantedAuthority> authorities) {
                    super(username, password, authorities);
                }
            }
            ```
         * これでCustomUserDetailsの実装は完了です。
    * CustomUserDetailsServiceでCustomUserDetailsを返すように設定する
        * 現在は常にNotFoundExceptionが買えるようにしていますので、特定のusernameの時だけCustomUserDetailsを返すようにしましょう。
        * if文でCustomUserDetailsをreturnします
        * CustomUserDetailsには引数としてユーザー名、パスワード、権限を渡します。
            * new CustomUserDetails("tom", "password", Collections.emptyList());権限は今回は空のリストを渡しておきます。
        * 検証に必要なパスワードエンコーダーを渡していきます。
            * パスワードをハッシュ化するための仕組みです。
            * SecurityConfigで設定をします。
            * auth.userDetailsService(userDetailsService);の後ろに.で続けて、以下のように書き換えます。
            ```java
            auth.userDetailsService(userDetailsService)
                .passwordEncoder(NoOpPasswordEncoder.getInstance());
            ```
            * NoOpPasswordEncoderは非推奨ですが、仮実装ですので、今回はこれを使います。
### ユーザーを管理するテーブルを作成しよう
```SQL
    create table users (
    username varchar(50) not null primary key,
    password varchar(500) not null
    )
```

* h2-consoleからデータベースを確認する
    * loginページ以外に行けないので、configureクラスから設定を変更します。これはあくまでも開発用の処理なので、本番環境では設定しないようにしましょう。
    * SecurityConfigure.javaのconfigureメソッドの中身を修正します。
    * すでに記述しているログインページへ遷移させる`http.authorizeRequests()`とは別でもう一つ、`.authorizeRequests()`をログインページへ遷移させる`http.authorizeRequests()`よりも先に記述します。
    * `csrf()というメソッドでpostするときのセキュリティを無効にします。

    ```java
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
                .authorizeRequests().antMatchers("/h2-console/**").permitAll()
                .and()
                .csrf().ignoringAntMatchers("/h2-console/**")
                .and()
                .headers().frameOptions().disable();
        http
                .authorizeRequests()
                .mvcMatchers("/login/**").permitAll()
                .anyRequest().authenticated()
                .and()
                .formLogin()
                .loginPage("/login");

    }
    ```
    * これでh2-consoleに入れます（ログイン情報はapplication.propatiesに記載されています。

### ユーザーの初期データを登録しよう

    


